// For those who want the bleeding edge
buildscript {
    ext.kotlin_version = '1.1.3'

    repositories {
        jcenter()
        mavenCentral()
        maven {
            name = 'forge'
            url = 'http://files.minecraftforge.net/maven'
        }
        maven {
            name = "sonatype"
            url = "https://oss.sonatype.org/content/repositories/snapshots/"
        }
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.3-SNAPSHOT'
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
        classpath 'com.github.jengelman.gradle.plugins:shadow:1.2.3'
        classpath 'gradle.plugin.com.matthewprenger:CurseGradle:1.0.9'
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.1'
    }
}

apply plugin: 'kotlin'
apply plugin: 'net.minecraftforge.gradle.forge'
apply plugin: 'com.github.johnrengelman.shadow'
apply plugin: 'com.matthewprenger.cursegradle'
apply plugin: 'com.jfrog.bintray'
apply plugin: 'maven-publish'

def parseConfig(File config) {
    config.withReader {
        def prop = new Properties()
        prop.load(it)
        return (new ConfigSlurper().parse(prop))
    }
}

ext.config = parseConfig(file('build.properties'))
def privateConfig = file('private.properties').exists()
if (privateConfig)
    ext.priv = parseConfig(file('private.properties'))
def tagMatcher = "git tag --contains HEAD".execute().text =~ /v[-\d.]+/
ext["gitTag"] = tagMatcher.count > 0 ? tagMatcher[0] : null

def isRelease() { return project.gitTag == "v${project.version}" && System.getenv("CI") == "true" }

def forgeVersion = "${config.mc_version}-${config.forge_version}${config.forge_branch != '' ? '-' : ''}${config.forge_branch}"

def updateUrl = "https://raw.githubusercontent.com/PaleoCrafter/VanillaImmersion/master/metadata/promotions.json"
version = "${config.mc_version}-${config.mod_version}"
if (System.getenv("TRAVIS_BUILD_NUMBER") != null && System.getenv("TRAVIS_BRANCH") != "master") {
    version = "$version+${System.getenv("TRAVIS_BRANCH")}.b${System.getenv("TRAVIS_BUILD_NUMBER")}"
} else if (System.getenv("TRAVIS_BUILD_NUMBER") != null && !isRelease()) {
    version = "$version+b${System.getenv("TRAVIS_BUILD_NUMBER")}"
}
group = 'de.mineformers.vimmersion'
archivesBaseName = 'vanilla-immersion'

minecraft {
    version = forgeVersion
    runDir = 'run'
    mappings = config.mappings
    useDepAts = true

    replace '@VERSION@', config.mod_version
    replace 'acceptedMinecraftVersions = "*",', """acceptedMinecraftVersions = "[${config.mc_version}]","""
    replace 'required-after:forgelin', "required-after:forgelin@[${config.forgelin_version},)"
    replace 'required-after:forge;', "required-after:forge@[${config.forge_version},);"
    replace '@UPDATE_URL@', updateUrl

    replaceIn 'VanillaImmersion.kt'
}

repositories {
    maven {
        url "http://dvs1.progwml6.com/files/maven"
    }
    maven {
        url "http://maven.shadowfacts.net"
    }
    maven {
        name = "CurseForge"
        url = "https://minecraft.curseforge.com/api/maven/"
    }
    jcenter()
    mavenCentral()
}

configurations {
    shade
    compile.extendsFrom shade
}

dependencies {
    compile "net.shadowfacts:Forgelin:${config.forgelin_version}"
    deobfCompile "mezz.jei:jei_${config.mc_version}:${config.jei_version}"
    compile "org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version"
}

shadowJar {
    configurations = [project.configurations.shade]
    classifier ''
}

reobf {
    shadowJar { mappingType = 'SEARGE' }
}
tasks.build.dependsOn reobfShadowJar

// Force Kotlin to compile to Java 8 bytecode
compileKotlin {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}
compileTestKotlin {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}

import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import net.minecraftforge.gradle.user.TaskSourceCopy

// Mad hacks to make source replacements work for Kotlin
for (set in sourceSets) {
    def taskName = "source${set.name.capitalize()}Kotlin"
    def dir = new File(project.getBuildDir(), "sources/${set.name}/kotlin")
    task(taskName, type: TaskSourceCopy) {
        source = set.getKotlin()
        output = dir
    }
    def compileTask = tasks[set.getCompileTaskName("kotlin")]
    compileTask.source = dir
    compileTask.dependsOn taskName
    def dirPath = dir.toPath()
    compileKotlin.include {
        return it.file.toPath().startsWith(dirPath)
    }
}
sourceJar.from sourceSets.main.kotlin

processResources {
    // this will ensure that this task is redone when the versions change.
    inputs.property 'version', config.mod_version
    inputs.property 'mcversion', config.mc_version

    // replace stuff in mcmod.info, nothing else
    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'

        expand 'version': project.version, 'mcversion': project.minecraft.version, 'updateUrl': updateUrl
    }

    // copy everything else other than the mcmod.info
    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }
}

def signingKeyStore = privateConfig ? priv.signing_key_store : System.getenv("PROJECT_SIGNING_KEY_STORE")
def signingKeyAlias = privateConfig ? priv.signing_key_alias : System.getenv("PROJECT_SIGNING_KEY_ALIAS")
def signingKeyStorePass = privateConfig ? priv.signing_key_store_pass : System.getenv("PROJECT_SIGNING_KEY_STORE_PASS")
def signingKeyPass = privateConfig ? priv.signing_key_pass : System.getenv("PROJECT_SIGNING_KEY_PASS")

if (signingKeyStore != null) {
    task signJar(type: SignJar, dependsOn: reobfShadowJar) {
        keyStore = signingKeyStore
        alias = signingKeyAlias
        storePass = signingKeyStorePass
        keyPass = signingKeyPass
        inputFile = jar.archivePath
        outputFile = jar.archivePath
    }

    check.dependsOn signJar
}

def bintrayApi = privateConfig ? priv.bintray_api : System.getenv("PROJECT_BINTRAY_API")
def bintrayUser = privateConfig ? priv.bintray_user : System.getenv("PROJECT_BINTRAY_USER")

if (bintrayApi != null) {
    bintray {
        user = bintrayUser
        key = bintrayApi
        publications = ["VanillaImmersion"]

        pkg {
            repo = "MinecraftMods"
            name = "VanillaImmersion"
            licenses = ["MIT"]
            websiteUrl = 'http://minecraft.curseforge.com/projects/vanilla-immersion'
            issueTrackerUrl = 'https://github.com/PaleoCrafter/VanillaImmersion/issues'
            vcsUrl = "https://github.com/PaleoCrafter/VanillaImmersion.git"
            publicDownloadNumbers = true
            githubRepo = "PaleoCrafter/VanillaImmersion"
            publish = true

            version {
                name = project.version
                released = new Date()
                attributes = ["MC Version"        : config.mc_version,
                              "Min. Forge Version": forgeVersion]

                if (isRelease()) {
                    vcsTag = project.gitTag
                }
            }
        }
    }
}

publishing {
    publications {
        VanillaImmersion(MavenPublication) {
            from components.java

            groupId 'de.mineformers.vanillaimmersion'
            artifactId 'vanilla-immersion'
            version project.version

            artifact sourceJar {
                classifier "sources"
            }
        }
    }
}

sourceJar.dependsOn reobfShadowJar
bintrayUpload.dependsOn reobfShadowJar

def cfApi = privateConfig ? priv.cf_api : System.getenv("PROJECT_CURSE_API")
def cfProject = privateConfig ? priv.cf_project : System.getenv("PROJECT_CURSE_PROJECT")
def cfType = privateConfig ? priv.cf_type : System.getenv("PROJECT_CURSE_TYPE")

if (cfApi != null) {
    curseforge {
        def changeFile = file('metadata/changes.json')
        def changes = new JsonSlurper().parseText(changeFile.text)
        def lists = []
        [["additions", "addition"], ["changes", "change"], ["fixes", "fix"]].each {
            def (String key, String label) = it
            if (changes.containsKey(key) && !changes[key].isEmpty()) {
                def list = "<li><b>${key.capitalize()}</b> <ul>"
                changes[key].each {
                    list += "<li>$it</li>"
                }
                list += "</ul></li>"
                lists.add(list)
            }
        }
        def changelogBody = "<ul>${lists.join("\n")}</ul>"

        apiKey = cfApi
        project {
            id = cfProject
            changelogType = 'html'
            changelog = changelogBody
            releaseType = cfType
            addGameVersion config.mc_version

            relations {
                requiredLibrary 'shadowfacts-forgelin'
                optionalLibrary 'just-enough-items-jei'
            }

            mainArtifact(shadowJar) {
                displayName = "Vanilla Immersion - ${config.mod_version}"
            }
        }
    }

    afterEvaluate {
        curseforge.curseProjects.each { tasks["curseforge${it.id}"].dependsOn bintrayUpload }
    }
}

task release() {
    if (isRelease()) {
        println "Triggering release build"
        dependsOn "curseforge"
    } else
        dependsOn bintrayUpload
}

task generateChangelogs() {
    doLast {
        def changeFile = file('metadata/changes.json')
        def changes = new JsonSlurper().parseText(changeFile.text)
        def promotionFile = file('metadata/promotions.json')
        def promotions = new JsonSlurper().parseText(promotionFile.text)
        def promotionTexts = []
        def lists = []
        [["additions", "addition"], ["changes", "change"], ["fixes", "fix"]].each {
            def (String key, String label) = it
            if (changes.containsKey(key) && !changes[key].isEmpty()) {
                promotionTexts.add(changes[key].collect { "${label.capitalize()}: $it" }.join("\n"))
                def list = "  - **${key.capitalize()}**"
                changes[key].each {
                    list += "\n    - $it"
                }
                lists.add(list)
            }
        }
        def promotionText = promotionTexts.join("\n")
        promotions.promos["${config.mc_version}-latest"] = config.mod_version
        if (!promotions.containsKey(config.mc_version)) {
            promotions[config.mc_version] = [:]
        }
        promotions[config.mc_version][config.mod_version] = promotionText
        def newPromos = JsonOutput.prettyPrint(JsonOutput.toJson(promotions))
        promotionFile.text = newPromos
        def changelogFile = file("CHANGELOG.md")
        changelogFile.text = """Changelog
=========

### Version ${config.mod_version} for Minecraft ${config.mc_version}
**Note:** This version of the mod requires at least Forge version *$forgeVersion*.
${lists.join("\n")}
${changelogFile.text.readLines().drop(2).join("\n")}"""
    }
}

tasks.build.dependsOn(release)
